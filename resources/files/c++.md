## 关于右值引用

c++11的新特性，区分左值和右值的最简单方法是看是否能取地址。

左值可以取地址，右值不可以。

所谓左值引用，可以通过`T& a = b`表示，所谓右值引用，可以通过`T&& a = 2`表示，这里2是右值，a是2的右值引用，但是a有了名字也是左值。

## 关于move与forward

关于move，即可以将左值强制转化为右值引用，继而可以通过右值引用使用改值，从深层次来理解是

将对象的状态或者所有权从一个对象转移到另一个对象，没有内存拷贝，因而可以提高效率。

关于forward，可以理解为完美转发，意思是在模板<T>的配合下可以完美转发左值引用或者右值引用，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。

## 关于智能指针

### unique_ptr<T>

独占指针，任何时候只能有一个指针指向特定内存，其不允许拷贝构造，只允许移动构造，因此常常和move配合使用

### shared_ptr<T>

共享指针，有一个计数代表有多少个指针指向特定内存，当计数为零时释放内存

### weak_ptr<T>

配合共享指针使用，主要是避免shared_ptr互指导致死锁无法释放内存的问题。名字由来是因为在weak_ptr指针生命结束之时，不会对指向内存产生任何影响。也就是说，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。

![image-20230512195036988](C:\Users\zhenh\AppData\Roaming\Typora\typora-user-images\image-20230512195036988.png)

可以将weak_ptr提升为shared_ptr

## RAII原理介绍

RAII（**R**esource **A**cquisition **I**s **I**nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；

资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源

RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期

## C++11 多线程

```c++
    {   
        // 在lock_guard构造函数里加锁，在析构函数里解锁
        // 防止使用mutex加锁解锁的时候，忘记解锁unlock
        std::lock_guard<std::mutex> locker(mtx_);
        deq_.clear();
        isClose_ = true;
    }
```

```c++
std::condition_variable condConsumer_;

notify_one()与notify_all()常用来唤醒阻塞的线程。

notify_one()：因为只唤醒等待队列中的第一个线程；不存在锁争用，所以能够立即获得锁。其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()。

notify_all()：会唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁。那其余未获取锁的线程接着会怎么样？会阻塞？还是继续尝试获得锁？

答案是会继续尝试获得锁(类似于轮询)，而不会再次阻塞。当持有锁的线程释放锁时，这些线程中的一个会获得锁。而其余的会接着尝试获得锁。
```

C++ 3大基本特性：封装、继承、多态

多态与虚函数 多态=重写？：函数名相同，形参、返回值相同

重载：函数名相同，形参、返回值不同



auto_ptr为什么会被弃用？

因为当两个auto_ptr指针指向同一块内存时，很有可能重复释放，导致出错



c语言实现多线程的函数：



c++语言实现多线程的函数

unique_lock和lock_guard的区别？

lock_guard无法手动加锁和释放，只能依靠作用域，而unique_lock可以



